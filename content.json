{"meta":{"title":"Hexo","subtitle":"","description":"","author":"jia","url":"https://blog.jiascu.top","root":"/"},"pages":[{"title":"Repositories","date":"2022-03-04T02:51:09.450Z","updated":"2022-03-04T02:51:09.450Z","comments":false,"path":"repository/index.html","permalink":"https://blog.jiascu.top/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程","slug":"多线程","date":"2022-03-04T07:02:48.860Z","updated":"2022-03-04T07:03:25.026Z","comments":true,"path":"2022/03/04/多线程/","link":"","permalink":"https://blog.jiascu.top/2022/03/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程笔记： 狂神说Java多线程详解 - NotYourferry - 博客园 (cnblogs.com) https://blog.csdn.net/weixin_44517301/article/details/121714319（补充） 核心概念 线程创建 三种创建方式 Thread 例： 12345678910111213141516171819202122232425public class TestThread1 extends Thread&#123; @Override public void run() &#123; //run方法线程方法体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在看代码----&quot; + i); &#125; &#125; public static void main(String[] args) &#123; //创建一个线程对象 TestThread1 testThread = new TestThread1(); //start开启线程 testThread.start(); //主线程 for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;我在学习多线程-----&quot; + i); &#125; &#125;&#125; 实现Runnable（推荐使用！！！）实现原理：静态代理 例： 123456789101112131415161718192021222324public class TestRunable implements Runnable&#123; @Override public void run() &#123; //run方法线程方法体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在看代码----&quot; + i); &#125; &#125; public static void main(String[] args) &#123; //创建一个线程对象 TestRunable testRunable = new TestRunable(); new Thread(testRunable).start(); //name1:线程名字 new Thread(testRunable,&quot;name1&quot;).start(); //主线程 for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;我在学习多线程-----&quot; + i); &#125; &#125;&#125; 两种方法的比较 继承 Thread 类 子类继承 Thread 类具备多线程能力 启动线程：子类对象 .start() 不建议使用：避免 OOP 单继承局限性 实现 Runnable 接口 实现接口 Runnable 具有多线程能力 启动线程：传入目标对象 + Thread对象.start() 推荐使用：避免单继承局限性，方便同一个对象被多个线程使用。 实现Callable接口（了解即可）实现Callable接口，重写call方法。 实现 Callable 接口，需要返回值类型 重写 call 方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService &#x3D; Executor.newFixedThreadPool(1); 提交执行：Future result1 &#x3D; ser.submit(1); 获取结果：boolean r1 &#x3D; result.get() 关闭服务：ser.shutdownNow() 例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TestCallable implements Callable&lt;Boolean&gt; &#123; private String url; //网络图片地址 private String name; // 保存的文件名 public TestCallable(String url, String name) &#123; this.name = name; this.url = url; &#125; //下载图片线程的执行体 @Override public Boolean call() &#123; WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(&quot;下载了文件名为：&quot; + name); return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; TestCallable testThread1 = new TestCallable(&quot;https://img-blog.csdnimg.cn/20210531145950543.png&quot;, &quot;2.png&quot;); TestCallable testThread2 = new TestCallable(&quot;https://img-blog.csdnimg.cn/20210531145950543.png&quot;, &quot;3.png&quot;); TestCallable testThread3 = new TestCallable(&quot;https://img-blog.csdnimg.cn/20210531145950543.png&quot;, &quot;4.png&quot;); TestCallable testThread4 = new TestCallable(&quot;https://img-blog.csdnimg.cn/20210531145950543.png&quot;, &quot;5.png&quot;); //创建执行服务: ExecutorService service = Executors.newFixedThreadPool(4); //提交执行: Future&lt;Boolean&gt; r1 = service.submit(testThread1); Future&lt;Boolean&gt; r2 = service.submit(testThread2); Future&lt;Boolean&gt; r3 = service.submit(testThread3); Future&lt;Boolean&gt; r4 = service.submit(testThread4); // 获取结果: boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); boolean rs4 = r4.get(); //关闭服务: service.shutdownNow(); &#125; class WebDownloader &#123; //下载方法 public void downloader(String url, String name) &#123; try &#123; FileUtils.copyURLToFile(new URL(url), new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;IO异常，downler方法出现问题&quot;); &#125; &#125; &#125;&#125; Lambda表达式Lambda 表达式属于函数式编程的概念 λ 希腊字母表中排序第十一位的字母，英语名称为 Lambda 避免匿名内部类定义过多 其实质属于函数式编程的概念 去掉了一堆没有意义的代码,只留下核心逻辑 函数式接口的定义 1. 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。 123public interface Runnable&#123; public abstract void run();&#125; 2. 对于函数式接口，我们可以通过lambda 表达式来创建该接口的对象。 使用 1234567891011121314151617181920212223242526272829303132333435//例1//1.定义一个函数式接口interface ILike1 &#123; void lambda1();&#125;//2.用lambda简化，--&gt;函数式接口ILike1 like1 = ()-&gt;&#123; System.out.println(&quot;i like lambda1&quot;);&#125;;like1.lambda1();//例2interface ILike2 &#123; void lambda2(int a,int b);&#125;//2.用lambda简化，--&gt;函数式接口ILike2 like2 = (a,b)-&gt;&#123; System.out.println(&quot;i like lambda&quot; + a + b);&#125;;like2.lambda2(1,2);//例3 模拟Runnable使用Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.out.println(i); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;////&quot;);&#125;);thread.start(); Lambda表达式简化(由来)： 接口实现类 静态内部类 局部内部类 匿名内部类,没有类的名称,必须借助接口或者父类 lambda简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TestLambda &#123; //3.静态内部类 static class Like2 implements ILike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like Lambda2!&quot;); &#125; &#125; public static void main(String[] args) &#123; ILike like = new Like(); like.lambda(); Like2 like1 = new Like2(); like1.lambda(); //4.局部内部类 class Like3 implements ILike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like Lambda3!&quot;); &#125; &#125; Like3 like3 = new Like3(); like3.lambda(); //5.匿名内部类,没有类的名称,必须借助接口或者父类 like = new ILike() &#123; @Override public void lambda() &#123; System.out.println(&quot;I like Lambda4!&quot;); &#125; &#125;; like.lambda(); //lambda简化 like = () -&gt; &#123; System.out.println(&quot;I like Lambda5!&quot;); &#125;; like.lambda(); &#125;&#125;//定义一个函数式接口interface ILike &#123; void lambda();&#125;//实现类class Like implements ILike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like Lambda!&quot;); &#125;&#125; 线程状态五大状态： 创建状态 就绪状态 阻塞状态 运行状态 死亡状态 线程的一些常用方法 停止线程的方式 不推荐使用 JDK 提供的 stop ()、destroy()方法。【已弃用】 推荐线程自己停止下来 建议使用一个标志位进行终止变量 ， 当 flag &#x3D;&#x3D; false，则终止线程运行 方法： 建议线程正常停止—-》利用次数。不建议死循环 建议使用标志位—-》设置一个标志位 不要使用stop或destory 等过时或者JDK 不建议使用的方法 案例： 1234567891011121314151617181920212223242526272829303132333435public class TestStop implements Runnable&#123; //1.设置一个标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag) &#123; System.out.println(&quot;run...Thread-&gt;&quot; + i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标志位 public void stop() &#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestStop testStop = new TestStop(); //开启线程 new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;main&quot; + i); if (i == 900) &#123; //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(&quot;该线程停止了&quot;); &#125; &#125; &#125;&#125; 线程休眠——sleep() sleep（时间）指定当前线程阻塞的毫秒数 sleep 存在异常 InterruptedException sleep 时间达到后线程进入就绪状态 sleep 可以模拟网络延时，倒计时等 （故意设置延时收优化钱💴，不道德，比如某盘） sleep 每一个对象都有一个锁，sleep 不会释放锁 案例1： 123456789101112131415161718// 每一秒获取当前时间public class TestSleep2 &#123; public static void main(String[] args) &#123; //获取系统当前时间 Date startTime = new Date(System.currentTimeMillis()); while (true) &#123; try &#123; Thread.sleep(1000); //更新系统时间 System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime)); startTime = new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 案例2 1234567891011121314151617181920212223242526272829//模拟延时:放大问题的发生性public class TestSleep implements Runnable &#123; //票数 private int ticketNums = 10; @Override public void run() &#123; while (true) &#123; if (ticketNums &lt;= 0) &#123; break; &#125; //模拟延时 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;--&gt;拿到了第&quot; + ticketNums-- + &quot;票&quot;); &#125; &#125; public static void main(String[] args) &#123; TestSleep ticket = new TestSleep(); new Thread(ticket, &quot;小明&quot;).start(); new Thread(ticket, &quot;老师&quot;).start(); new Thread(ticket, &quot;黄牛&quot;).start(); &#125;&#125; 线程礼让——yield() 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让 CPU 从新调度，有可能还是调度该礼让线程，礼让不一定成功 案例： 123456789101112131415161718192021//线程礼让不一定成功，看cpu心情public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield, &quot;a&quot;).start(); new Thread(myYield, &quot;b&quot;).start(); &#125;&#125;class MyYield implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始运行！&quot;); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName() + &quot;线程结束运行！&quot;); &#125;&#125; 合并线程——Join()Join 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。 可以想象成插队。 案例：多核达不到预期效果 12345678910111213141516171819202122232425//测试join方法，想象为插队public class TestJoin implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;vip线程来了&quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //线程启动 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); //主线程 for (int i = 0; i &lt; 500; i++) &#123; if (i == 200) &#123; thread.join();//插队 &#125; System.out.println(&quot;main线程&quot; + i); &#125; &#125;&#125; 线程状态观测Thread.State 线程状态：线程可以处于以下状态之一： NEW：尚未启动的线程处于此状态。 创建状态 RUNNABLE：在 Java 虚拟机中执行的线程处于此状态。 运行状态 BLOCKED：被阻塞等待监视器锁定的线程处于此状态。 阻塞状态 WAITING：正在等待另一个线程执行特定动作的线程处于此状态。 就绪状态 TERMINATED：已退出的线程处于此状态。 死亡状态 一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。 死亡之后的线程不能再次启动，一个线程只能启动一次 方法：thread.getState() 案例： 12345678910111213141516171819202122232425262728293031public class TestState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.out.println(i); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;////&quot;); &#125;); //观察线程状态 Thread.State state = thread.getState(); System.out.println(state); //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); while (state != Thread.State.TERMINATED) &#123; Thread.sleep(100); state = thread.getState(); System.out.println(state); &#125; &#125;&#125; 线程优先级Java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 优先级高的获得cpu的几率更大些，不是优先级高的就先执行完，线程优先级随机特性 线程的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY&#x3D;1 Thread.MAX_PRIORITY&#x3D;10 Thread.NORM_PRIORITY&#x3D;5 使用以下方式改变或获取优先级 getPriority().setPriority(int xxx) 优先级的设定建议在 start() 调度前 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//测试线程的优先级public class TestPriority extends Thread &#123; //主线程默认优先级 public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级， 再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(MAX_PRIORITY);//MAX_PRIORITY=10 t4.start();/* t5.setPriority(-1); t5.start(); t6.setPriority(11); t6.start();*/ &#125;&#125;class MyPriority implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + Thread.currentThread().getPriority()); &#125;&#125; 守护（daemon）线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕：main 虚拟机不用等待守护线程执行完毕：gc垃圾回收进程 如后台记录操作日志，监控内存垃圾回收等待 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142//测试守护线程//上帝守护你public class TestDaemon &#123; public static void main(String[] args) &#123; God god = new God(); You you = new You(); Thread thread = new Thread(god); thread.setDaemon(true);//默认线程是用户线程 thread.start(); new Thread(you).start();//你启动 &#125;&#125;//上帝class God implements Runnable &#123; @Override public void run() &#123; while (true) &#123; System.out.println(&quot;上帝永远保佑着你！&quot;); &#125; &#125;&#125;//你class You implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 36500; i++) &#123; System.out.println(&quot;你开心的生活每一天！&quot;); &#125; System.out.println(&quot;=========goodbye,world!&quot;); &#125;&#125; 线程同步 并发：同一对象被多个线程同时操作（抢票） 线程同步是一个等待机制，多个需要同时访问次对象的线程进入这个对象的等待池形成队列，等待前一个线程使用完毕，下一个线程才能使用。 形成条件：队列+锁 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可.存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题. 线程不安全举例1. 不安全的售票(已根据4.2改成安全) 1234567891011121314151617181920212223242526272829303132333435363738394041424344//线程不安全，买票重复public class UnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket, &quot;我&quot;).start(); new Thread(buyTicket, &quot;你&quot;).start(); new Thread(buyTicket, &quot;他&quot;).start(); &#125;&#125;class BuyTicket implements Runnable &#123; //票 private int ticket = 10; //外部停止标志 boolean flag = true; @Override public void run() &#123; //买票 while (flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //synchronized:同步方法，锁的是this public synchronized void buy() throws InterruptedException &#123; if (ticket &lt;= 0) &#123; flag = false; return; &#125; //模拟延时 Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot;买到&quot; + ticket--); &#125;&#125; 2.不安全取钱(已根据4.2改成安全) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//取钱线程不安全public class UnsafeBank &#123; public static void main(String[] args) &#123; //账户 Account account = new Account(1000, &quot;结婚基金&quot;); Drawing you = new Drawing(account, 50, &quot;你&quot;); Drawing girlFriend = new Drawing(account, 100, &quot;girlFriend&quot;); you.start(); girlFriend.start(); &#125;&#125;class Account &#123; //账户名称 String name; //账户余额 int money; public Account(int money, String name) &#123; this.name = name; this.money = money; &#125;&#125;class Drawing extends Thread &#123; Account account;//银行账户 int drawingMoney;//取了多少钱 int nowMoney;//剩余多少钱 public Drawing(Account account, int drawingMoney, String name) &#123; this.account = account; this.drawingMoney = drawingMoney; super.setName(name); &#125; //取钱 @Override public void run() &#123; //synchronized块：锁的是变化的量 synchronized (account) &#123; if (account.money - drawingMoney &lt; 0) &#123; System.out.println(&quot;卡内余额不足，取不了！&quot;); return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 卡内余额 = 余额–你取的钱 account.money = account.money - drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name + &quot;余额为:&quot; + account.money); //Thread.currentThread().getName() == this.getName() System.out.println(this.getName() + &quot;手里的钱&quot; + nowMoney); &#125; &#125;&#125; 3.不安全的集合(已根据4.2改成安全) 12345678910111213141516171819//线程不安全的集合public class UnsafeList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; synchronized (list) &#123; list.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 同步方法及同步块由于我们可以通过关键字 private 关键字来保证数据对象只能被方法访问，所以我们只要针对方法提出一套机制，这套机制就是 synchronized 关键字， 它包括两种方法：synchronized 方法和 synchronized 块. synchronized 方法: 1public synchronized void method(int args)&#123;&#125; synchronized 方法控制 “对象” 的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法申明为 synchronized 将会影响效率。 synchronized 块: 同步块：synchronized(Obj){} Obj 称之为同步监视器 Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this ，就是这个对象本身，或者是 class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中的代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 锁的是变化的量 JUC安全集合类型扩充 1234567891011121314151617public class TestJUC &#123; public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 死锁和Lock锁 死锁： 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥“两个以上对象的锁”时，就可能会发生“死锁”的问题。 产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 上述四个条件，只要破坏其任意一个或多个条件就可避免死锁的发生。 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 死锁:多个线程互相抱着对方需要的资源,然后形成僵持 * 解决:一个锁只锁一个对象 */public class DeadLock &#123; public static void main(String[] args) &#123; Makeup makeup = new Makeup(0, &quot;灰姑娘&quot;); Makeup makeup1 = new Makeup(1, &quot;白雪公主&quot;); makeup.start(); makeup1.start(); &#125;&#125;//口红class Lipstick &#123; &#125;//镜子class Mirror &#123; &#125;class Makeup extends Thread &#123; //需要的资源只有一份,用static保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice;//选择 String girlName;//使用化妆品的人 public Makeup(int choice, String girlName) &#123; this.choice = choice; this.girlName = girlName; &#125; @Override public void run() &#123; //化妆 try &#123; makeup(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private void makeup() throws InterruptedException &#123; if (choice == 0) &#123; synchronized (lipstick) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); Thread.sleep(1000); synchronized (mirror) &#123;//一秒钟后想获得镜子 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); &#125; &#125; &#125; else &#123; synchronized (mirror) &#123;//获得口红镜子 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); Thread.sleep(2000); synchronized (lipstick) &#123;//二秒钟后想获得的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); &#125; &#125; &#125; &#125;&#125; // 解决:一个锁只锁一个对象 private void makeup() throws InterruptedException &#123; if (choice == 0) &#123; synchronized (lipstick) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); Thread.sleep(1000); &#125; synchronized (mirror) &#123;//一秒钟后想获得镜子 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); &#125; &#125; else &#123; synchronized (mirror) &#123;//获得口红镜子 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); Thread.sleep(2000); &#125; synchronized (lipstick) &#123;//二秒钟后想获得的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); &#125; &#125; &#125; Lock(锁): 从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显示定义同步锁对象来实现同步。同步锁使用 Lock对象充当 java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock对象。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock ，可以显示加锁释放锁。 synchronized 与 Lock 的对比: Lock 是显示锁（手动开启和关闭），synchronized 是隐式锁，出了作用域自动释放 Lock 只有代码加锁，synchronized 有代码块锁和方法锁 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并具有更好的扩展性（提供更多的子类） Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外） 案例： 12345678910111213141516171819202122232425262728293031323334353637383940//测试Lock锁public class TestLock &#123; public static void main(String[] args) &#123; TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); &#125;&#125;class TestLock2 implements Runnable &#123; int ticketNums = 10; //定义lock锁:可重入锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock();//加锁 if (ticketNums &gt; 0) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(ticketNums--); &#125; else &#123; break; &#125; &#125; finally &#123; lock.unlock();//解锁 &#125; &#125; &#125;&#125; 线程通信应用场景：生产者和消费者问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。 如果仓库中没有产品，则将生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费，直到仓库中再次放入产品为止。 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待.而生产了产品之后，又需要马上通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费. 在生产者消费者问题中，仅有synchronized是不够的 synchronized ：可阻止并发更新同一个共享资源，实现了同步，不能用来实现不同线程之间的消息传递（通信） 解决线程通信的几个方法注意：均是 Object 类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常 illegalMonitorStateException 解决线程之间通信的方式管程法并发写作模型””生产者&#x2F;消费者模式””–&gt;管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程） 消费者：负责处理数据的模块（可能是方法，对象，线程，进程） 缓冲区：消费者不能直接使用生产者的数据，他们之间有个缓冲区 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//测试：生产者消费者模型---》管程法//消费者，生产者，商品，缓冲区public class TestPC &#123; public static void main(String[] args) &#123; SyncContainer syncContainer = new SyncContainer(); new Customer(syncContainer).start(); new Producer(syncContainer).start(); &#125;&#125;//消费者class Customer extends Thread &#123; //创建缓冲区 private SyncContainer syncContainer; public Customer(SyncContainer syncContainer) &#123; this.syncContainer = syncContainer; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; Product pop = syncContainer.pop(); System.out.println(&quot;消费了第&quot; + pop.getId() + &quot;号产品&quot;); &#125; &#125;&#125;//生产者class Producer extends Thread &#123; //创建新的缓冲区 private SyncContainer syncContainer; public Producer(SyncContainer syncContainer) &#123; this.syncContainer = syncContainer; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;生产了&quot; + i + &quot;只鸡！&quot;); syncContainer.push(new Product(i)); &#125; &#125;&#125;//商品class Product &#123; int id;//产品编号 public Product(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SyncContainer &#123; //定义容器大小 Product[] products = new Product[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Product product) &#123; //如果容器满了，就等待消费者消费 if (count == products.length) &#123; //通知消费者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 如果没有满，我们就需要丢入产品 products[count] = product; count++; //通知消费者消费 this.notifyAll(); &#125; //消费者消费产品 public synchronized Product pop() &#123; if (count == 0) &#123; //通知生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Product product = products[count]; //通知生产者消费 this.notifyAll(); return product; &#125;&#125; 信号灯法通过标志位解决 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//测试生产者消费者问题2：信号灯法，通过标志位解决public class TestPC2 &#123; public static void main(String[] args) &#123; TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者--&gt;演员class Player extends Thread &#123; TV tv; public Player(TV tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (i % 2 == 0) &#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125; else &#123; this.tv.play(&quot;抖音：记录美好生活&quot;); &#125; &#125; &#125;&#125;//消费者--&gt;观众class Watcher extends Thread &#123; TV tv; public Watcher(TV tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; tv.watch(); &#125; &#125;&#125;//产品--&gt;节目class TV &#123; //演员表演，观众等待 T //观众观看，演员等待 F String voice; // 表演的节目 boolean flag = true; //表演 public synchronized void play(String voice) &#123; if (!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了：&quot; + voice); //通知观众观看 this.notifyAll(); this.voice = voice; this.flag = !this.flag; &#125; //观看 public synchronized void watch() &#123; if (flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了：&quot; + voice); //通知演员表演 this.notifyAll(); this.flag = !this.flag; &#125;&#125; 使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 优点： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理… corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间会终止 案例： 123456789101112131415161718192021222324252627//测试线程池public class TestPool &#123; public static void main(String[] args) &#123; //1.创建服务，创建线程池 ExecutorService service = Executors.newFixedThreadPool(10); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭链接 service.shutdown(); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; //for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()); //&#125; &#125;&#125; 线程总结创建线程的三种方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ThreadNew &#123; public static void main(String[] args) &#123; new MyThread1().start(); new Thread(new MyThread2()).start(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread3()); new Thread(futureTask).start(); try &#123; Integer integer = futureTask.get(); System.out.println(integer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//1.继承Thread类class MyThread1 extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;MyThread1&quot;); &#125;&#125;//实现Runnable接口class MyThread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;MyThread2&quot;); &#125;&#125;//实现Callable接口class MyThread3 implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;MyThread3&quot;); return 100; &#125;&#125;","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2022-03-04T06:59:14.547Z","updated":"2022-03-04T06:59:47.654Z","comments":true,"path":"2022/03/04/设计模式/","link":"","permalink":"https://blog.jiascu.top/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"23种设计模式（GoF 23）有人推荐韩顺平的 文档笔记：(5条消息) (狂神)初识设计模式笔记_愿你拥有大风与烈酒,也能享受孤独与自由-CSDN博客_狂神设计模式笔记 设计模式分类 创建型模式（new对象）：描述怎么创建一个对象，并使得创建对象和使用对象分离，就是不在一个代码块里面 结构型模式：描述怎么来设计类的结构 行为型模式：描述类或对象之间怎么相互协作，去完成单个对象不能完成的任务 OOP七大原则 单例模式(需补充，并发不会) 饿汉式单例 1234567891011121314151617181920// 饿汉式单例public class Hungry &#123; //可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry()&#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 双重检测锁模式的 懒汉式单例 DCL懒汉式 12345678910111213141516171819202122232425262728293031323334353637383940//懒汉式单例public class LazyMan &#123; private LazyMan()&#123; //System.out.println(Thread.currentThread().getName() + &quot;ok&quot;); &#125; private volatile static LazyMan lazyMan; //双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance()&#123; if (lazyMan == null)&#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; lazyMan = new LazyMan();//不是一个原子性操作 &#125; &#125; &#125; return lazyMan; &#125; /** * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 123 * 132 A * B // 此时lazyMan还没有完成构造 */ // // 多线程并发 // public static void main(String[] args) &#123; // for (int i = 0; i &lt; 10; i++) &#123; // new Thread(()-&gt;&#123; // LazyMan.getInstance(); // &#125;).start(); // &#125; // &#125;&#125; 工厂模式 简单(静态)工厂模式 不满足开闭原则 123456789101112131415161718192021222324//静态工厂模式public class CarFactory &#123; //方法一 public static Car getCar(String car)&#123; if (car.equals(&quot;五菱&quot;))&#123; return new WuLing(); &#125;else if (car.equals(&quot;特斯拉&quot;))&#123; return new Tesla(); &#125;else &#123; return null; &#125; &#125; //方法二 public static Car getWuling()&#123; return new WuLing(); &#125; public static Car getTesla()&#123; return new Tesla(); &#125;&#125; 工厂方法模式 满足开闭原则 代码结构： 比较 结构复杂度: simple 代码复杂度: simple 编程复杂度: simple 管理上的复杂度: simple 根据设计原则:工厂方法模式! 根据实际业务:简单工厂模式! 抽象工厂模式抽象的抽象 围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂 UML类图 产品族与产品等级 建造者模式 方式一 方式二，简化：去除director 优缺点、应用场景、比较： 原型模式克隆：浅克隆与深克隆 深克隆： 改造clone方法 序列化与反序列化：性能比较低下 适配器模式适配器： 继承（类适配器，单继承） 123456public class Adapter extends Adaptee implements NetToUsb&#123; @Override public void handleRequest() &#123; super.request(); //可以上网了 &#125;&#125; 组合 （对象适配器：常用） 推荐！！！ 12345678910public class Adapter2 implements NetToUsb&#123; private Adaptee adaptee; public Adapter2(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void handleRequest() &#123; adaptee.request(); &#125;&#125; 示例：网线——转换器——电脑接口 优缺点 桥接模式 桥接模式 桥接模式是将抽象部分与它的实现部分分离, 使他们都可以独立地变化, 它是一种对象结构型模式, 又称为柄体(Handle and Body)模式或接口(Interface)模式 优劣 代理模式 静态代理 角色分析: 抽象角色: 一般会使用接口或抽象类来解决 真实角色: 被代理的角色 代理角色: 代理真实角色,代理真实角色后,我们一般会做一些附属操作 客户: 访问代理对象的人 代码步骤 接口 真实角色 代理角色 客户端访问代理角色 优缺点 代理模式的好处: 可以使真实角色的操作更加纯粹,不用去关注一些公共的业务 公共也就交给代理角色,实现了业务的分工 公共业务发生扩展的时候,方便集中管理 缺点: 一个真实角色就会产生一个代理角色,代码量会翻倍,开发效率会变低 静态代理再理解 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的,不是我们直接写好的 动态代理分为两大类 : 基于接口的动态代理,基于类的动态代理 基于接口-JDK动态代理【我们在这里使用】 基于类: cglib java字节码实现 : javassist 需要了解的两个类: Proxy: 代理, InvocationHandler: 调用处理程序 InvocationHandler(调用处理程序) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.jia.proxy.demo04;import com.jia.proxy.demo03.Rent;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * User: jia * Time: 2022/2/16 19:10 * Description: * Version: *///或用这个类自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); //动态代理的本质,就是使用反射机制实现 Object result = method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; 好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！","categories":[],"tags":[]},{"title":"JUC并发编程","slug":"JUC并发编程","date":"2022-03-04T06:49:05.545Z","updated":"2022-03-04T06:49:36.258Z","comments":true,"path":"2022/03/04/JUC并发编程/","link":"","permalink":"https://blog.jiascu.top/2022/03/04/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"","text":"JUC并发编程笔记： JUC并发编程笔记（狂神说） - 你我不在年少 - 博客园 (cnblogs.com) https://blog.csdn.net/weixin_44491927/article/details/108560692 https://www.cnblogs.com/futuresky/p/15016732.html 什么是JUCJUC就是java.util.concurrent下面的类包，专门用于多线程的开发 concurrent：同时，并发 java.util 工具包 业务：无法通过普通的线程代码 Thread实现。 Runnable 没有返回值、效率相比于Callable相对较低！ 企业开发中Callable 使用较多 线程和进程 进程是操作系统中的应用程序、是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位 一个进程往往可以包含多个线程，至少包含一个 进程进程是程序的一次执行，QQ.EXE Music.EXE；程序的集合 一个进程可以包含多个线程，至少包含一个线程！ Java默认有几个线程？2个线程！ main线程、GC线程 线程开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的) 对于Java而言：Thread、Runable、Callable进行开启线程的。 &#x3D;&#x3D;提问？JAVA真的可以开启线程吗？ 开不了的！&#x3D;&#x3D; Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。 并发多线程操作同一个资源。 CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。 并发编程的本质：充分利用CPU的资源！ 并行并行： 多个人一起行走 CPU多核，多个线程可以同时执行。 我们可以使用线程池！ 获取cpu的线程数（逻辑处理器） 123456public class Test1 &#123; public static void main(String[] args) &#123; //获取cpu的核数 System.out.println(Runtime.getRuntime().availableProcessors()); &#125;&#125; 线程的状态12345678910111213141516171819public enum State &#123; //新生 NEW, //运行 RUNNABLE, //阻塞 BLOCKED, //等待 WAITING, //超时等待 TIMED_WAITING, //终止 TERMINATED;&#125; wait&#x2F;sleep1、来自不同的类 wait &#x3D;&gt; Object sleep &#x3D;&gt; Thread 一般情况企业中使用休眠是： 12TimeUnit.DAYS.sleep(1); //休眠1天TimeUnit.SECONDS.sleep(1); //休眠1s 2、关于锁的释放 wait 会释放锁； sleep睡觉了，不会释放锁； 3、使用的范围是不同的 wait 必须在同步代码块中； sleep 可以在任何地方睡； 4、是否需要捕获异常 wait也需要捕获异常；（网上非常多的代码说不用抛出异常，应该是没去看源码和尝试吧，下面附图，其实文章上一张源码的图也显示需要抛出异常），notify和notifyAll不需要捕获异常。）中断 sleep必须要捕获异常； Lock锁（重点）传统的 synchronized12345678910111213141516171819202122232425262728293031323334353637383940public class SaleTicketDemo01 &#123; public static void main(String[] args) &#123; // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;&#123; 代码 &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 40 ; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 40 ; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 40 ; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;// 资源类 OOPclass Ticket &#123; // 属性、方法 private int number = 30; // 卖票的方式 // synchronized 本质: 队列，锁 public synchronized void sale()&#123; if (number&gt;0)&#123; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(number--)+&quot;票,剩余：&quot;+number); &#125; &#125;&#125; Lock 公平锁： 十分公平，必须先来后到~； 非公平锁： 十分不公平，可以插队；**(默认为非公平锁)** 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SaleTicketDemo02 &#123; public static void main(String[] args) &#123; final Ticket2 ticket = new Ticket2(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;C&quot;).start(); &#125;&#125;//lock三部曲//1、 Lock lock=new ReentrantLock();//2、 lock.lock() 加锁//3、 finally=&gt; 解锁：lock.unlock();class Ticket2 &#123; private int number = 30; // 创建锁 Lock lock = new ReentrantLock(); //卖票的方式 public synchronized void sale() &#123; lock.lock(); // 开启锁 try &#123; if (number &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张票剩余&quot; + number + &quot;张票&quot;); &#125; &#125;finally &#123; lock.unlock(); // 关闭锁 &#125; &#125;&#125; Synchronized 与Lock 的区别 Synchronized 内置的Java关键字，Lock是一个Java类 Synchronized 无法判断获取锁的状态，Lock可以判断 Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！可能会遇到死锁 Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个trylock去尝试获取锁，不会造成长久的等待。 Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁； Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码； 生产者和消费者问题面试：单例模式、排序算法、生产者和消费者、死锁问题 wait方法：会释放锁！ Synchronized 版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 线程之间的通信问题：生产者和消费者问题！ 等待唤醒，通知唤醒 * 线程交替执行 A B 操作同一个变量 num = 0 * A num+1 * B num-1 *///顺序：判断待-&gt;业务-&gt;通知public class A &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;class Data &#123; private int number = 0; //+1 public synchronized void increment() throws InterruptedException &#123; if (number != 0) &#123; //等待 this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); // 通知其他线程，我+1完毕了 this.notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; if (number == 0) &#123; //等待 this.wait(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); // 通知其他线程，我-1完毕了 this.notifyAll(); &#125;&#125; 存在问题（虚假唤醒） 问题，如果有四个线程，会出现虚假唤醒 解决方式 ，if 改为while即可，防止虚假唤醒 结论：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后 代码：有问题，四个线程不能跑完四个循环（输出的不是40个） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class A &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;C&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;D&quot;).start(); &#125;&#125;class Data &#123; private int number = 0; //+1 public synchronized void increment() throws InterruptedException &#123; while (number != 0) &#123; //等待 this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); // 通知其他线程，我-1完毕了 this.notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; while (number == 0) &#123; //等待 this.wait(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); // 通知其他线程，我-1完毕了 this.notifyAll(); &#125;&#125; Lock版（JUC） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class B &#123; public static void main(String[] args) &#123; Data2 data = new Data2(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;C&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;D&quot;).start(); &#125;&#125;class Data2 &#123; private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); // +1 public void increment() throws InterruptedException &#123; lock.lock(); try &#123; // 判断等待 while (num != 0) &#123; condition.await(); &#125; num++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 condition.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; // -1 public void decrement() throws InterruptedException &#123; lock.lock(); try &#123; // 判断等待 while (num == 0) &#123; condition.await(); &#125; num--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 condition.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; Condition的优势 精准的通知和唤醒的线程！ 如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Description： * A 执行完 调用B * B 执行完 调用C * C 执行完 调用A * * @author jiaoqianjin * Date: 2020/8/11 9:58 **/public class C &#123; public static void main(String[] args) &#123; Data3 data3 = new Data3(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data3.printA(); &#125; &#125;,&quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data3.printB(); &#125; &#125;,&quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data3.printC(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;class Data3 &#123; private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int num = 1; // 1A 2B 3C public void printA() &#123; lock.lock(); try &#123; // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 1) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;==&gt; AAAA&quot; ); num = 2; condition2.signal(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; lock.lock(); try &#123; // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;==&gt; BBBB&quot; ); num = 3; condition3.signal(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; lock.lock(); try &#123; // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;==&gt; CCCC&quot; ); num = 1; condition1.signal(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;/*A==&gt; AAAAB==&gt; BBBBC==&gt; CCCCA==&gt; AAAAB==&gt; BBBBC==&gt; CCCC...*/ 8锁现象如何判断锁的是谁！锁到底锁的是谁？ 锁会锁住：对象、Class 深刻理解我们的锁 问题1两个同步方法，先执行发短信还是打电话 123456789101112131415161718public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone phone = new Phone(); new Thread(phone::sendMs).start(); TimeUnit.SECONDS.sleep(1); new Thread(phone::call).start(); &#125;&#125;class Phone &#123; public synchronized void sendMs() &#123; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call() &#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 结果：先发短信，然后再打电话！ 问题2我们让发短信 延迟4s 12345678910111213141516171819202122232425public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; try &#123; phone.sendMs(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); new Thread(phone::call).start(); &#125;&#125;class Phone &#123; public synchronized void sendMs() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); &#125; public synchronized void call() &#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 结果：还是先发短信，然后再打电话！ why？ 原因：并不是顺序执行，而是synchronized 锁住的对象是方法的调用者！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待 问题3加一个普通方法hello 12345678910111213141516171819202122232425262728public class Test2 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone2 phone = new Phone2(); new Thread(() -&gt; &#123; try &#123; phone.sendMs(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); new Thread(phone::hello).start(); &#125;&#125;class Phone2 &#123; public synchronized void sendMs() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); &#125; public synchronized void call() &#123; System.out.println(&quot;打电话&quot;); &#125; public void hello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 结果：hello 发短信 原因：hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放 问题4如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？ 1234567891011121314151617181920212223242526public class Test2 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone2 phone1 = new Phone2(); Phone2 phone2 = new Phone2(); new Thread(() -&gt; &#123; try &#123; phone1.sendMs(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); new Thread(phone2::call).start(); &#125;&#125;class Phone2 &#123; public synchronized void sendMs() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); &#125; public synchronized void call() &#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 结果：打电话 发短信 原因：两个对象两把锁，不会出现等待的情况，发短信睡了4s,所以先执行打电话 问题5，6如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？ （1）我们先来使用一个对象调用两个方法！ 答案是：先发短信,后打电话 （2）如果我们使用两个对象调用两个方法！ 答案是：还是先发短信，后打电话 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Test3 &#123; public static void main(String[] args) &#123; // 两个对象的Class类模板只有一个，static，锁的是Class Phone3 phone1 = new Phone3(); Phone3 phone2 = new Phone3(); //锁的存在 new Thread(()-&gt;&#123; phone1.sendSms(); &#125;,&quot;A&quot;).start(); // 捕获 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone2.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;// Phone3唯一的一个 Class 对象class Phone3&#123; // synchronized 锁的对象是方法的调用者！ // static 静态方法 // 类一加载就有了！锁的是Class public static synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public static synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 原因是什么呢？ 为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？ 原因：对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！ 问题7，8如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？ （1）一个对象，先打印 发短信？打电话？ 答案是：先打电话,后发短信 （2）两个对象，先打印 发短信？打电话？ 答案是：还是先发短信，后打电话 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.concurrent.TimeUnit;/** * 1、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？ * 2、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？ */public class Test4 &#123; public static void main(String[] args) &#123; // 两个对象的Class类模板只有一个，static，锁的是Class Phone4 phone1 = new Phone4(); Phone4 phone2 = new Phone4(); //锁的存在 new Thread(()-&gt;&#123; phone1.sendSms(); &#125;,&quot;A&quot;).start(); // 捕获 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone2.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;// Phone3唯一的一个 Class 对象class Phone4&#123; // 静态的同步方法 锁的是 Class 类模板 public static synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; // 普通的同步方法 锁的调用者 public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 原因：两把锁锁的不是同一个东西，静态的同步方法锁的是 Class 类模板，普通的同步方法 锁的调用者 小结 锁对象：new this 具体的一个手机，对象和对象之间不共用锁 锁class：static Class 唯一的一个模板，对象和模板之间不共用锁 即：锁：static Class模板、对象1、对象2… 集合不安全List 不安全123456789101112public class ListTest &#123; public static void main(String[] args) &#123; List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=10;i++)&#123; new Thread(()-&gt;&#123; arrayList.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(arrayList); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 会导致java.util.ConcurrentModificationException 并发修改异常 ArrayList 在并发情况下是不安全的 解决方案： 123456789101112131415161718192021public class ListTest &#123; public static void main(String[] args) &#123; /** * 解决方案 * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for(int i=1;i&lt;=10;i++)&#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; CopyOnWriteArrayList：写入时复制！ COW 计算机程序设计领域的一种优化策略 核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。 读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。 多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）； 在写入的时候避免覆盖，造成数据错乱的问题； 读写分离 CopyOnWriteArrayList比Vector厉害在哪里？ Vector底层是使用synchronized关键字来实现的：效率特别低下。 CopyOnWriteArrayList使用的是Lock锁，效率会更加高效！ set 不安全 Set和List同理可得: 多线程情况下，普通的Set集合是线程不安全的； 解决方案还是两种： 使用Collections工具类的synchronized包装的Set类 使用CopyOnWriteArraySet 写入复制的JUC解决方案 1234567891011121314151617public class SetTest &#123; public static void main(String[] args) &#123; /** * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); */// Set&lt;String&gt; set = new HashSet&lt;&gt;(); Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 1; i &lt;= 30; i++) &#123; new Thread(() -&gt; &#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; HashSet底层是什么？ hashSet底层就是一个HashMap； Map不安全1234//map 是这样用的吗？ 不是，工作中不使用这个//默认等价什么？ new HashMap&lt;&gt;(16,0.75);Map&lt;String, String&gt; map = new HashMap&lt;&gt;();//加载因子、初始化容量 默认加载因子是0.75,默认的初始容量是16 同样的HashMap基础类也存在并发修改异常！ 12345678910111213141516171819public class MapTest &#123; public static void main(String[] args) &#123; //map 是这样用的吗？ 不是，工作中不使用这个 //默认等价什么？ new HashMap&lt;&gt;(16,0.75); /** * 解决方案 * 1. Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); * Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); */ Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); //加载因子、初始化容量 for (int i = 1; i &lt; 100; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5)); System.out.println(map); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 作业:研究ConcurrentHashMap底层原理： Callable 1、可以有返回值； 2、可以抛出异常； 3、方法不同，run()&#x2F;call() 代码测试 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //new Thread(new Runnable()).start(); //new Thread(new FutureTask&lt;V&gt;()).start(); //new Thread(new FutureTask&lt;V&gt;( Callable )).start(); //new Thread().start();// 怎么启动Callable MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask,&quot;A&quot;).start(); new Thread(futureTask,&quot;B&quot;).start();// 结果会被缓存，效率高，结果只打印一次 //获取Callable的返回结果 String o = (String) futureTask.get();//这个get 方法可能会产生阻塞！把他放到最后 或者使用异步通信来处理！ System.out.println(o); &#125;&#125;class MyThread implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;jjjj&quot;); // 耗时的操作 return &quot;hello&quot;; &#125;&#125; 细节： 1、有缓存 2、结果可能需要等待，会阻塞！ 常用的辅助类(高并发必会)加法计数器，减法计数器和信号量 CountDownLatch减法计数器 主要方法： countDown 减一操作； await 等待计数器归零 await 等待计数器归零，就唤醒，再继续向下运行 代码： 123456789101112131415public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 总数是6 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;==&gt; Go Out&quot;); countDownLatch.countDown(); // 每个线程都数量 -1 &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); // 等待计数器归零 然后向下执行 System.out.println(&quot;close door&quot;); &#125;&#125; CyclickBarrier加法计数器 代码： 123456789101112131415161718192021222324public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; /** * 集齐7颗龙珠召唤神龙 */ // 召唤龙珠的线程 CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙。。。&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; // lambda不能操作到 i , 必须为不修改的常量 final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;收集第&quot;+temp+&quot;颗龙珠&quot;); try &#123; cyclicBarrier.await(); //等待 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; CyclicBarrier 与 CountDownLatch 区别 CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的 CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。 Semaphore（信号量）抢车位！6车—3个停车位置 代码： 1234567891011121314151617181920212223242526public class SemaphoreDemo &#123; public static void main(String[] args) &#123; // 线程数量：停车位! 用来限流！ Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; //acquire() 得到 //release() 释放 try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+&quot;抢到车位！&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+&quot;离开车位！&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理： semaphore.acquire(); 获得，假设如果已经满了，等待，等待被释放为止！ semaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！ 作用： 多个共享资源互斥的使用！并发限流，控制最大的线程数！ 读写锁ReadWriteLock 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 独占锁（写锁） 一次只能被一个线程占有 * 共享锁（读锁） 多个线程可以同时占有 * ReadWriteLock * 读-读 可以共存 * 读-写 不能共存 * 写-写 不能共存 */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; //MyCache myCache = new MyCache(); MyCacheLock myCache = new MyCacheLock(); int num = 6; for (int i = 1; i &lt;= num; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; myCache.write(String.valueOf(finalI), String.valueOf(finalI)); &#125;,String.valueOf(i)).start(); &#125; for (int i = 1; i &lt;= num; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; myCache.read(String.valueOf(finalI)); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;class MyCacheLock &#123; private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 读写锁，更加细粒度的控制 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //写的时候，只希望同时只有一个线程写 public void write(String key, String value) &#123; readWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;); map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; //读，所有人都可以读 public void read(String key) &#123; readWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;线程读取ok&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125;/** * 方法未加锁，导致写的时候被插队 */class MyCache &#123; private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); public void write(String key, String value) &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;); map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;); &#125; public void read(String key) &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;线程写读取ok&quot;); &#125;&#125; 阻塞队列写入：如果队列满了就必须阻塞等待 取：如果队列是空的，必须阻塞等待生产 阻塞队列： BlockingQueue 有四组api 方式 抛出异常 不会抛出异常，有返回值 阻塞，等待 超时等待 添加 add offer() put offer(timenum.timeUnit) 移出 remove poll() take poll(timenum,timeUnit) 判断队首元素 element peek - - 抛出异常 1234567891011121314151617181920public static void test1()&#123; //需要初始化队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.add(&quot;a&quot;)); System.out.println(blockingQueue.add(&quot;b&quot;)); System.out.println(blockingQueue.add(&quot;c&quot;)); //抛出异常：java.lang.IllegalStateException: Queue full //System.out.println(blockingQueue.add(&quot;d&quot;)); System.out.println(blockingQueue.element()); //查看队首元素是谁 System.out.println(&quot;---------------------&quot;); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //如果多移除一个 //这也会造成 java.util.NoSuchElementException 抛出异常 //System.out.println(blockingQueue.remove());&#125; 不抛出异常，有返回值 1234567891011121314151617public static void test2()&#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;)); //添加一个不能添加的元素 使用offer只会返回false 不会抛出异常 System.out.println(blockingQueue.offer(&quot;d&quot;)); System.out.println(blockingQueue.peek()); //查看队首元素是谁 System.out.println(&quot;---------------------&quot;); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); //弹出 如果没有元素 只会返回null 不会抛出异常 System.out.println(blockingQueue.poll());&#125; 等待 一直阻塞 123456789101112131415161718public static void test3() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); //一直阻塞 不会返回 blockingQueue.put(&quot;a&quot;); blockingQueue.put(&quot;b&quot;); blockingQueue.put(&quot;c&quot;); //如果队列已经满了， 再进去一个元素 这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止 //blockingQueue.put(&quot;d&quot;); System.out.println(&quot;---------------------&quot;); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //如果我们再来一个 这种情况也会等待，程序会一直运行 阻塞 System.out.println(blockingQueue.take());&#125; 等待 超时阻塞 这种情况也会等待队列有位置 或者有产品 但是会超时结束 12345678910111213141516public static void test4() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); blockingQueue.offer(&quot;a&quot;); blockingQueue.offer(&quot;b&quot;); blockingQueue.offer(&quot;c&quot;); System.out.println(&quot;开始等待&quot;); blockingQueue.offer(&quot;d&quot;,2, TimeUnit.SECONDS); //超时时间2s 等待如果超过2s就结束等待 System.out.println(&quot;结束等待&quot;); System.out.println(&quot;===========取值==================&quot;); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(&quot;开始等待&quot;); blockingQueue.poll(2,TimeUnit.SECONDS); //超过两秒 我们就不要等待了 System.out.println(&quot;结束等待&quot;);&#125; 补充：同步队列SynchronousQueue 同步队列没有容量，也可以视为容量为1的队列； 进去一个元素，必须等待取出来之后，才能再往里面放入一个元素； put方法 和 take方法； Synchronized 和 其他的BlockingQueue 不一样 它不存储元素； put了一个元素，就必须从里面先take出来，否则不能再put进去值！ 并且SynchronousQueue 的take是使用了lock锁保证线程安全的 12345678910111213141516171819202122232425262728293031public class SynchronousQueueDemo &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;(); // 网queue中添加元素 new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;); synchronousQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;); synchronousQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;); synchronousQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); // 取出元素 new Thread(()-&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; take &quot; + synchronousQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; take &quot; + synchronousQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; take &quot; + synchronousQueue.take()); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 线程池(重点)线程池：三大方法、7大参数、4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 &#x3D;&#x3D;&#x3D;&gt; 池化技术 线程池、JDBC的连接池、内存池、对象池 等等。。。。 资源的创建、销毁十分消耗资源 池化技术：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。 默认大小：3 max： 线程池的好处： 1、降低资源的消耗； 2、提高响应的速度； 3、方便管理； 线程复用、可以控制最大并发数、管理线程； 三大方法阿里规范： 三大方法： ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程 ExecutorService threadPool2 &#x3D; Executors.newFixedThreadPool(5); &#x2F;&#x2F;创建一个固定的线程池的大小 ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool(); &#x2F;&#x2F;可伸缩的 案例： 1234567891011121314151617181920212223//Executors 工具类， 3大方法public class Demo01 &#123; public static void main(String[] args) &#123; //ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程 //ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定的线程池大小 ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的，遇强则强，遇弱则弱 try &#123; for (int i = 0; i &lt; 10; i++) &#123; // 使用了线程池之后，使用线程池来创建线程 threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; OK&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 线程池用完，程序结束，关闭线程池 threadPool.shutdown(); &#125; &#125;&#125; 七大参数三者本质上都是调用ThreadPoolExecutor 三大方法源码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, //21亿 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; // 本质ThreadPoolExecutor（） public ThreadPoolExecutor(int corePoolSize, // 核心线程池大小 int maximumPoolSize, // 最大核心线程池大小 long keepAliveTime, // 超时了没有人调用就会释放 TimeUnit unit, // 超时单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory,// 线程工厂：创建线程的，一般不用动 RejectedExecutionHandler handler// 拒绝策略 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 手动创建一个线程池 1234567891011121314151617181920212223242526272829303132333435/** * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常 * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！ main线程 * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！ * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和最早的竞争，也不会抛出异常！只会尝试 */public class Demo01 &#123; public static void main(String[] args) &#123; //自定义线程池！工作 ThreadPoolExecutor ExecutorService threadPool = new ThreadPoolExecutor( 2,// 核心线程池大小 5,// 最大核心线程池大小 4,//超时时间 TimeUnit.SECONDS,//超时单位 new LinkedBlockingQueue&lt;&gt;(3),//候客区 Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());//银行满了，还有人进来，不处理这个人的，抛出异常 try &#123; //最大承载：Deque + max （5+3） //超过 RejectedExecutionException for (int i = 1; i &lt;= 9; i++) &#123; // 使用了线程池之后，使用线程池来创建线程 threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; OK&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 线程池用完，程序结束，关闭线程池 threadPool.shutdown(); &#125; &#125;&#125; 四种拒绝策略 new ThreadPoolExecutor.AbortPolicy() &#x2F;&#x2F; 银行满了，还有人进来，不处理这个人的，抛出异常 new ThreadPoolExecutor.CallerRunsPolicy() &#x2F;&#x2F; 哪来的去哪里！ main线程 new ThreadPoolExecutor.DiscardPolicy() &#x2F;&#x2F;队列满了，丢掉任务，不会抛出异常！ new ThreadPoolExecutor.DiscardOldestPolicy() &#x2F;&#x2F;队列满了，尝试去和最早的竞争，也不会抛出异常！只会尝试 扩展如何设置线程池的最大大小（调优） 最大线程池大小该如何定义： 1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小 代码获取CPU核数： 1System.out.println(Runtime.getRuntime().availableProcessors()); 2、I&#x2F;O密集型： 在程序中有15个大型任务，io十分占用资源； I&#x2F;O密集型就是判断我们程序中十分耗I&#x2F;O的线程数量，大约是最大I&#x2F;O数的一倍到两倍之间。 四大函数式接口（必须掌握）新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算 函数式接口：只有一个方法的接口 12345678910@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;// 传统技术必会：泛型、枚举、反射// 新技术必会：lambda表达式、链式编程、函数式接口、Stream流式计算// 超级多FunctionalInterface// 简化编程模型，在新版本的框架底层大量应用！// foreach(消费者类的函数式接口) 四大函数式接口：Function、Predicate、Suppier、Consummer 参数 返回值 Function 有 有 Predicate 有 Boolean Suppier 无 无 Consummer 有 无 Function 函数型接口传入参数T，返回参数R 代码： 12345678910111213141516171819202122/** * Function 函数型接口, 有一个输入参数，有一个输出, * 只要是函数型接口，就可以用 lambda表达式简化 */public class Demo01 &#123; public static void main(String[] args) &#123; //工具类：输出输入的值 Function function = new Function&lt;String, String&gt;() &#123; @Override public String apply(String str) &#123; return str; &#125; &#125;; //只要是函数型接口，就可以用 lambda表达式简化 Function function1 = (str) -&gt; &#123; return str; &#125;; System.out.println(function1.apply(&quot;123&quot;)); &#125;&#125; Predicate 断定型接口传入参数T，返回Boolean值 代码： 123456789101112131415161718192021/** * 断定型接口：有一个输入参数，返回值只能是 布尔值！ */public class Demo02 &#123; public static void main(String[] args) &#123; //判断字符串是否为空 Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123; @Override public boolean test(String str) &#123; return str.isEmpty(); &#125; &#125;; //只要是函数型接口，就可以用 lambda表达式简化 Predicate&lt;String&gt; predicate2 = (str) -&gt; &#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;asddd&quot;)); &#125;&#125; Suppier 供给型接口没有参数，只有返回值 代码： 1234567891011121314151617181920/** * Supplier 供给型接口 没有参数，只有返回值 */public class Demo04 &#123; public static void main(String[] args) &#123; Supplier supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; return 1024; &#125; &#125;; //只要是函数型接口，就可以用 lambda表达式简化 Supplier supplier2 = () -&gt; &#123; return 1024; &#125;; System.out.println(supplier2.get()); &#125;&#125; Consummer 消费型接口只有参数，没有返回值 1234567891011121314151617181920/** * Consumer 消费型接口: 只有输入，没有返回值 */public class Demo03 &#123; public static void main(String[] args) &#123; Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123; @Override public void accept(String str) &#123; System.out.println(str); &#125; &#125;; //只要是函数型接口，就可以用 lambda表达式简化 Consumer&lt;String&gt; consumer1 = (str) -&gt; &#123; System.out.println(str); &#125;; consumer.accept(&quot;qwre&quot;); &#125;&#125; Stream流式计算 什么是Stream流式计算 大数据：存储 + 计算 集合、MySQL 本质就是存储东西的； 计算都应该交给流来操作！ 案例 User类 12345678@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private int id; private String name; private int age;&#125; Test 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 题目要求：一分钟内完成此题，只能用一行代码实现！ * 现在有5个用户！筛选： * 1、ID 必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户！ */public class Test &#123; public static void main(String[] args) &#123; User u1 = new User(1, &quot;a&quot;, 21); User u2 = new User(2, &quot;b&quot;, 22); User u3 = new User(3, &quot;c&quot;, 23); User u4 = new User(4, &quot;d&quot;, 24); User u5 = new User(6, &quot;e&quot;, 25); // 集合是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // list.stream(); // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u -&gt; &#123; return u.getId() % 2 == 0; &#125;) .filter(u -&gt; &#123; return u.getAge() &gt; 23; &#125;) .map(u -&gt; &#123; return u.getName().toUpperCase(); &#125;) .sorted((uu1, uu2) -&gt; &#123; return uu2.compareTo(uu1); &#125;) .limit(1) .forEach(System.out::println); &#125;&#125; ForkJoin中文：分支合并 ForkJoin 在JDK1.7，并行执行任务！提高效率。在大数据量速率会更快！ 大数据中：MapReduce 核心思想-&gt;把大任务拆分为小任务！ ForkJoin 特点： 工作窃取！ 实现原理是：双端队列！从上面和下面都可以去拿到任务进行执行！ ForkJoin使用 通过ForkJoinPool来执行 计算任务 execute(ForkJoinTask&lt;?&gt; task) 计算类要去继承ForkJoinTask； ForkJoin 的计算类 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 求和计算的任务 * 3000 6000(ForkJoin) 9000(Stream并行流) * */public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private long start; private long end; /** 临界值 */ private long temp = 1000000L; public ForkJoinDemo(long start, long end) &#123; this.start = start; this.end = end; &#125; /** * 计算方法 * @return */ @Override protected Long compute() &#123; if ((end - start) &lt; temp) &#123; long sum = 0L; for (long i = start; i &lt; end; i++) &#123; sum += i; &#125; return sum; &#125;else &#123; // 使用ForkJoin 分而治之 计算 //1 . 计算平均值 long middle = (start + end) / 2; ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork();// 拆分任务，把线程压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle, end); task2.fork(); long taskSum = task1.join() + task2.join(); return taskSum; &#125; &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ForkJoinTest &#123; private static final long SUM = 20_0000_0000; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test1(); test2(); test3(); &#125; /** * 使用普通方法 */ public static void test1() &#123; long star = System.currentTimeMillis(); long sum = 0L; for (long i = 1; i &lt; SUM ; i++) &#123; sum += i; &#125; long end = System.currentTimeMillis(); System.out.println(sum); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;----------------------&quot;); &#125; /** * 使用ForkJoin 方法 */ public static void test2() throws ExecutionException, InterruptedException &#123; long star = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, SUM); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); //提交任务 Long along = submit.get(); System.out.println(along); long end = System.currentTimeMillis(); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;-----------&quot;); &#125; /** * 使用 Stream 流计算 */ public static void test3() &#123; long star = System.currentTimeMillis(); long sum = LongStream.range(0L, 20_0000_0000L).parallel().reduce(0, Long::sum); System.out.println(sum); long end = System.currentTimeMillis(); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;-----------&quot;); &#125;&#125; 结果： 注意 long和Long的区别： long：基本数据类型，与int，float类似 Long：对象，与Integer类似 long比Long运算速度快的多！！！ 扩充：java八大基本数据类型及其封装类 简单类型 boolean byte char short Int long float double void 二进制位数 1 8 16 16 32 64 32 64 – 封装器类 Boolean Byte Character Short Integer Long Float Double Void Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。 基本类型的优势：数据存储相对简单，运算效率比较高 包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想 异步回调 Future 设计的初衷： 对将来的某个事件的结果进行建模 其实就是前端 –&gt; 发送ajax异步请求给后端 但是我们平时都使用CompletableFuture 没有返回值的runAsync异步回调 123456789101112131415161718192021222324/** * 异步调用： CompletableFuture * // 异步执行 * // 成功回调 * // 失败回调 */public class Demo01 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 发起一个请求 void // 没有返回值的 runAsync 异步回调 CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;void&quot;); &#125;); System.out.println(&quot;11111111&quot;); completableFuture.get();//获取执行结果 &#125;&#125; 有返回值的异步回调supplyAsync 12345678910111213141516171819public class Demo01 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 有返回值的 runAsync 异步回调 // 成功返回，失败返回错误信息 CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;supplyAsync=&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123; System.out.println(&quot;t=&gt;&quot; + t); //正常的返回结果 System.out.println(&quot;u=&gt;&quot; + u); //错误信息 java.util.concurrent.CompletionException &#125;).exceptionally((e) -&gt; &#123; System.out.println(e.getMessage()); return 233; //可以获取到错误的返回结果 &#125;).get()); &#125;&#125; whenComplete: 有两个参数，一个是t 一个是u T：是代表的 正常返回的结果； U：是代表的 抛出异常的错误信息； 如果发生了异常，get可以获取到exceptionally返回的值； 理解 异步回调：开启另外一个线程去执行任务，主线程可获得另外一个线程的执行结果（与多线程的不同） Mqtt (应用)：MqttCallback回调函数 JMM 对Volatile 的理解 Volatile 是 Java 虚拟机提供 轻量级的同步机制 1、保证可见性 2、不保证原子性 3、禁止指令重排 什么是JMM？ JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！ 关于JMM的一些同步的约定： 1、线程解锁前，必须把共享变量立刻刷回主存； 2、线程加锁前，必须读取主存中的最新值到工作内存中； 3、加锁和解锁是同一把锁； 内存交互操作有8种: Read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用； load（载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中； Use（使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令； assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中； store（存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用； write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中； lock（锁定）：作用于主内存的变量，把一个变量标识为线程独占状态； unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定； 注意：下面这幅图中write和store的顺序反了，应该先store再write JMM对这八种指令的使用，制定了如下规则： 不允许read和load、store和write操作之一单独出现，必须成对使用。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量对一个变量进行unlock操作之前，必须把此变量同步回主内存问题： 程序不知道主内存的值已经被修改过了 案例 12345678910111213141516171819public class JMMDemo &#123; private static int num = 0; public static void main(String[] args) &#123; //main new Thread(()-&gt;&#123; //线程1 对主内存的变化不知道的 while (num == 0 )&#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125;/**结果：程序未暂停，线程中num一直为0*/ volatileVolatile 是 Java 虚拟机提供 轻量级的同步机制 1、保证可见性 2、不保证原子性 3、禁止指令重排 保证可见性1234567891011121314151617181920212223public class JMMDemo &#123; // 不加 volatile 程序就会死循环！ // 加 volatile 可以保证可见性 private volatile static int num = 0; public static void main(String[] args) &#123; //main new Thread(()-&gt;&#123; //线程1 对主内存的变化不知道的 while (num == 0 )&#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 不保证原子性原子性：不可分割； 线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。 123456789101112131415161718192021222324252627282930313233/** * 不保证原子性 * number &lt;=2w * */public class VDemo02 &#123; private static volatile int number = 0; public static void add()&#123; number++; //++ 不是一个原子性操作，是两个~3个操作 // &#125; public static void main(String[] args) &#123; //理论上number === 20000 for (int i = 1; i &lt;= 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;= 1000 ; j++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2)&#123; //main gc //main gc Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number); &#125;&#125; 如果不加lock和synchronized ，怎么样保证原子性？ 使用原子类，解决原子性问题，比锁高效很多倍！ 1234567891011121314151617181920212223242526public class VDemo02 &#123; private static volatile AtomicInteger number = new AtomicInteger(); public static void add()&#123; number.getAndIncrement(); // AtomicInteger +1 方法 ，CAS &#125; public static void main(String[] args) &#123; //理论上number === 20000 for (int i = 1; i &lt;= 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;= 1000 ; j++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2)&#123; //main gc Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number); &#125;&#125; 这些类的底层都直接和操作系统挂钩！是在内存中修改值。 Unsafe类是一个很特殊的存在； 禁止指令重排 什么是指令重排？ 我们写的程序，计算机并不是按照我们自己写的那样去执行的 源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行 处理器在进行指令重排的时候，会考虑数据之间的依赖性！ 1234567int x=1; //1int y=2; //2x=x+5; //3y=x*x; //4//我们期望的执行顺序是 1_2_3_4 可能执行的顺序会变成2134 1324//可不可能是 4123？ 不可能的 可能造成的影响结果：前提：a b x y这四个值 默认都是0 线程A 线程B x&#x3D;a y&#x3D;b b&#x3D;1 a&#x3D;2 正常的结果： x &#x3D; 0; y &#x3D;0; 线程A 线程B b&#x3D;1 a&#x3D;2 x&#x3D;a y&#x3D;b 可能在线程A中会出现，先执行b&#x3D;1,然后再执行x&#x3D;a； 在B线程中可能会出现，先执行a&#x3D;2，然后执行y&#x3D;b； 那么就有可能结果如下：x&#x3D;2; y&#x3D;1. volatile可以避免指令重排： volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。 内存屏障：CPU指令。作用： 1、保证特定的操作的执行顺序； 2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性） volatile在上下加上两层内存屏障，防止指令重排。 在哪里内存屏障用得最多？单例模式 玩转单例模式为什么枚举可以避免单例模式被破坏？ 饿汉式 DCL懒汉式，深究！ 饿汉式123456789101112131415161718//饿汉式单例public class Hungry &#123; //一上来就实例化，可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; //私有化构造器 private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL懒汉式 懒汉式单例 123456789101112131415161718192021222324252627282930313233// 懒汉式单例public class LazyMan &#123; //私有化构造器 private LazyMan() &#123; System.out.println(Thread.currentThread().getName()+&quot; OK&quot;); &#125; private static LazyMan lazyMan; public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); &#125; return lazyMan; &#125; //多线程并发 ，会有隐患！ public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; lazyMan.getInstance(); &#125;).start(); &#125; &#125;&#125;/**可能结果：Thread-0 OKThread-2 OKThread-1 OK*/ 双重检测锁模式的 懒汉式单例（DCL懒汉式） 123456789101112131415161718192021222324252627282930313233343536373839public class LazyMan &#123; //私有化构造器 private LazyMan() &#123; System.out.println(Thread.currentThread().getName()+&quot; OK&quot;); &#125; private static LazyMan lazyMan; //双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance() &#123; if (lazyMan == null)&#123; synchronized (LazyMan.class)&#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); //不是一个原子性操作 /** * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 123 * 132 A * B // 此时lazyMan还没有完成构造 */ &#125; &#125; &#125; return lazyMan; &#125; //多线程并发 public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; lazyMan.getInstance(); &#125;).start(); &#125; &#125;&#125; 双重检测锁 + 原子性操作 的懒汉式单例（DCL懒汉式） 加volatile 123456789101112131415161718192021222324252627282930313233343536373839public class LazyMan &#123; //私有化构造器 private LazyMan() &#123; System.out.println(Thread.currentThread().getName()+&quot; OK&quot;); &#125; private volatile static LazyMan lazyMan; //双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance() &#123; if (lazyMan == null)&#123; synchronized (LazyMan.class)&#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); //不是一个原子性操作 /** * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 123 * 132 A * B // 此时lazyMan还没有完成构造 */ &#125; &#125; &#125; return lazyMan; &#125; //多线程并发 public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; lazyMan.getInstance(); &#125;).start(); &#125; &#125;&#125; 静态内部类1234567891011public class Holder &#123; private Holder()&#123; &#125; public static Holder getInstance()&#123; return InnerClass.holder; &#125; public static class InnerClass&#123; private static final Holder holder = new Holder(); &#125;&#125; 以上都不安全，可以通过反射破坏！ 枚举使用枚举，我们就可以防止反射破坏了。 1234567891011121314151617181920//enum 是什么？ enum本身就是一个Class 类public enum EnumSingle &#123; INSTANCE; public EnumSingle getInstance()&#123; return INSTANCE; &#125;&#125;class Test&#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; EnumSingle instance1 = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class); declaredConstructor.setAccessible(true); //java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;() EnumSingle instance2 = declaredConstructor.newInstance(); System.out.println(instance1); System.out.println(instance2); &#125;&#125; 深入理解CAS 什么是CAS？ 进大厂必须要深入研究底层！否则进不去！有所突破！ 修内功，操作系统，计算机网络原理。 CAS : compareAndSet 比较并交换 java代码： 1234567891011121314151617181920public class CASDemo &#123; //CAS : compareAndSet 比较并交换 public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); //boolean compareAndSet(int expect, int update) //期望值、更新值 //如果实际值 和 我的期望值相同，那么就更新 //如果实际值 和 我的期望值不同，那么就不更新 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); //因为期望值是2020 实际值却变成了2021 所以会修改失败 //CAS 是CPU的并发原语 atomicInteger.getAndIncrement(); //++操作 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); &#125;&#125; Unsafe 类 总结 CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。 缺点： 循环会耗时； 一次性只能保证一个共享变量的原子性； 它会存在ABA问题 CAS：ABA问题（狸猫换太子） 线程1：期望值是1，要变成2； 线程2：两个操作： 1、期望值是1，变成3 2、期望是3，变成1 所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1； 12345678910111213141516171819202122public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); //平时写的SQL：乐观锁 //期望 更新 //public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 77777)); System.out.println(atomicInteger.get()); &#125;&#125; 原子引用 解决ABA 问题：引入原子引用，对应的思想：乐观锁！ 带版本号 的原子操作！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CASDemo &#123; // AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 // 正常在业务操作，这里面比较的都是一个个对象 static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp();//获得版本号 System.out.println(&quot;a1=&gt;&quot;+stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicStampedReference.compareAndSet(10, 11, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(11, 10, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a3=&gt;&quot;+atomicStampedReference.getStamp()); &#125;,&quot;a&quot;).start(); new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp();//获得版本号 System.out.println(&quot;b1=&gt;&quot;+stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicStampedReference.compareAndSet(10, 15, stamp, stamp + 1)); System.out.println(&quot;b2=&gt;&quot;+atomicStampedReference.getStamp()); &#125;,&quot;b&quot;).start(); &#125;&#125; 注意： Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间； 阿里巴巴开发手册： 各种锁的理解公平锁，非公平锁公平锁： 非常公平， 不能够插队，必须先来后到！ 非公平锁：非常不公平，可以插队 （默认都是非公平） 源码： 1234567public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 可重入锁可重入锁（递归锁） Synchronized 1234567891011121314151617181920212223public class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone&#123; public synchronized void sms()&#123; System.out.println(Thread.currentThread().getName()+&quot;：sms&quot;); call();//这里也有锁 &#125; public synchronized void call()&#123; System.out.println(Thread.currentThread().getName()+&quot;：call&quot;); &#125;&#125; Lock 版 1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo02 &#123; public static void main(String[] args) &#123; Phone2 phone = new Phone2(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;B&quot;).start(); &#125;&#125;class Phone2 &#123; Lock lock = new ReentrantLock(); public synchronized void sms() &#123; lock.lock();// 细节问题：lock.lock(); lock.unlock(); // lock锁必须配对，lock与unlock成对出现，否则就会死在里面 try &#123; System.out.println(Thread.currentThread().getName() + &quot;：sms&quot;); call();//这里也有锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public synchronized void call() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;：call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; lock锁必须配对，相当于lock和 unlock 必须数量相同； 在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁； 自旋锁spinlock 源码 自我设计 自旋锁 自定义一个锁： 1234567891011121314151617181920212223242526/** * 自旋锁 */public class SpinlockDemo &#123; // 初始： int -&gt; 0; 引用类型 Thread -&gt; null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); // 加锁 public void myLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt;myLock&quot;); //自旋锁 while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; // 解锁 public void myUnlock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt;myUnlock&quot;); //自旋锁 atomicReference.compareAndSet(thread, null); &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536public class TestSpinLock &#123; public static void main(String[] args) &#123; //ReentrantLock ReentrantLock reentrantLock = new ReentrantLock(); reentrantLock.lock(); reentrantLock.unlock(); // 底层使用的自旋锁CAS SpinlockDemo lock = new SpinlockDemo(); new Thread(()-&gt;&#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnlock(); &#125; &#125;,&quot;T1&quot;).start(); new Thread(()-&gt;&#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnlock(); &#125; &#125;,&quot;T2&quot;).start(); &#125;&#125; 运行结果： t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。。。 死锁 死锁是什么 死锁测试 123456789101112131415161718192021222324252627282930313233343536public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start(); new Thread(new MyThread(lockB, lockA), &quot;T2&quot;).start(); &#125;&#125;class MyThread implements Runnable &#123; private String lockA; private String lockB; public MyThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA); &#125; &#125; &#125;&#125; 解决问题 1、使用jps定位进程号，jdk的bin目录下： 有一个jps 命令：jps -l 输入命令的位置： 2、使用jstack 进程进程号 找到死锁信息 一般情况信息在最后： 面试：工作中排查问题： 查看日志 堆栈信息！！！","categories":[],"tags":[]},{"title":"IDEA调试技巧","slug":"IDEA调试技巧","date":"2022-03-03T13:47:51.680Z","updated":"2022-03-04T03:38:48.091Z","comments":true,"path":"2022/03/03/IDEA调试技巧/","link":"","permalink":"https://blog.jiascu.top/2022/03/03/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","excerpt":"","text":"IDEA调试技巧断点统一开关Mute Breakpoints 条件断点断点处点击右键 单步调试 Step Over (F8) 下一步（行） Step Into (F7) 进入方法内部 Force Step Into (Alt + Shift + F7) 强制进入方法内部 Step Out (Shift + F8) 退出当前方法 表达式求值Evaluate Expression (Alt + F8) 计算表达式 基本用法总结、快捷键第一组按钮共8个按钮，从左到右依次如下： Show Execution Point (Alt + F10) 如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。 Step Over (F8) 下一步（行） 步过，一行一行地往下走，如果这一行上有方法不会进入方法。 Step Into (F7) 进入方法内部 步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。 Force Step Into (Alt + Shift + F7) 强制进入方法内部 强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 Step Out (Shift + F8) 退出当前方法 步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 Drop Frame 回退断点 Run to Cursor (Alt + F9) 运行到光标处 你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。 Evaluate Expression (Alt + F8) 计算表达式 第二组按钮共7个按钮，从上到下依次如下： Rerun ‘xxxx’ 重新运行程序，会关闭服务后重新启动程序。 Update ‘tech’ application (Ctrl + F5) 更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里 Resume Program (F9) 只在断点停留 恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了 Pause Program 暂停程序，启用Debug。 Stop ‘xxx’ (Ctrl + F2) 连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。 View Breakpoints (Ctrl + Shift + F8) 查看所有断点 Mute Breakpoints 关闭断点 哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。","categories":[],"tags":[]},{"title":"else","slug":"else","date":"2022-03-03T13:47:51.660Z","updated":"2022-03-04T03:33:08.463Z","comments":true,"path":"2022/03/03/else/","link":"","permalink":"https://blog.jiascu.top/2022/03/03/else/","excerpt":"","text":"get、post请求区别 get：查询、搜索 post： 更新 登录注册等表单 对于博客、论坛、数据的上传下载 挂载到服务器上 clean package 数据库、JDBC、数据库连接池的区别 **&#x3D;&#x3D;JDBC(Java Database Connectivity)&#x3D;&#x3D;**： java和数据库的连接技术，sun公司推出的一套java应用程序访问数据库的技术规范。 数据库连接池 Druid、hikari：普通的JDBC数据库连接使用 DriverManager 来获取,但是会出现很多问题。为了解决传统开发中数据库的连接问题，使用&#x3D;&#x3D;数据库连接池负责分配、管理和释放数据库连接&#x3D;&#x3D;","categories":[],"tags":[]},{"title":"IDEA快捷键","slug":"快捷键","date":"2022-03-03T13:47:51.624Z","updated":"2022-03-04T03:36:13.789Z","comments":true,"path":"2022/03/03/快捷键/","link":"","permalink":"https://blog.jiascu.top/2022/03/03/%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"IDEA快捷键 重写方法： alt + insert 然后点击override ctrl + o alt + enter 引入局部变量 遍历快捷键：变量.for(i) 例如： 1Cookies.forio if快捷键：变量.if main函数快捷键：psvm 1public static void main(String[] args) &#123;&#125; 定义类时， 自动生成get和set方法：alt + insert 然后点击Getter and Setter 自动生成构造方法：alt + insert 然后点击Constructor 重写toSring方法：alt + insert 然后点击tostring jsp代码注释不顶头写：ctrl + shift + &#x2F; 运行java文件快捷键：ctrl + shift +F10 Tab &#x2F; Shift + Tab ： 缩进一次所选择的代码段 Tab ：右缩进 Shift + Tab ： 左缩进 快速提取方法：Ctrl + Alt + M （鼠标右击 》Refactor 》Extract 》Method） sout等价于： 1System.out.println(); 也能通过 .sout 使用 ctrl+f : 文档中搜索 ctrl+r：文档中替换 双击shift：全局搜索类、文件等 ctrl+shift+alt：多行选中修改 idea格式化代码快捷键： 去掉空白： Ctrl + Shift + J 格式化代码： Ctrl + Alt + L（与QQ快捷键冲突，建议修改，或使用时关闭QQ） 在某一文件夹迅速运行cmd命令：路径上操作：路径前面加上cmd 直接运行 大小写转换：ctr + shift + u 函数方法添加注释：自动给IDEA类和方法添加注释（小白完美版） - 知乎 (zhihu.com) 使用方法：首先新建一个方法，然后在方法的上方输入/**，按回车Enter，即可自动生成注释信息 try-catch-finally快捷键： 默认：ctrl + alt +T(冲突) 建议修改为alt +T","categories":[],"tags":[]},{"title":"注解","slug":"注解","date":"2022-03-03T13:47:43.108Z","updated":"2022-03-04T03:36:32.134Z","comments":true,"path":"2022/03/03/注解/","link":"","permalink":"https://blog.jiascu.top/2022/03/03/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"springmvc123456789101112@Controller : 代表这个类会被Spring接管 被这个注解的类中所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析 @RequestMapping(&quot;/t3&quot;)：请求映射 @GetMapping：get方法 @PostMapping：post方法 @PutMapping @DeleteMapping @PatchMapping@PathVariable : 让方法参数的值对应绑到一个URL模板变量上@RequestParam(&quot;username&quot;)：前端请求的参数名@ResponseBody//它不会走视图解析器。会直接返回一个字符串@RestController：@Controller + @ResponseBody spring @Autowired：自动注入，首先按类型注入，如果只有一个则成功；如果是多个，再按照名称（类首字母小写）注入，找到了成功，否则失败 @Qualifier：@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Resource：自动装配通过名字、类型，使用时需先导包 @Nullable：标记字段，说明该字段可以为null bean注入：放在类上，说明这个类被Spring管理了，就是bean ​ 相当于： @Component：组件，放在pojo（实体类上） @Controller：web层 @Service：service层 @Repository：dao层 @value：属性注入，可在定义变量上方和set方法上方注入，表示为该属性赋值 ​ 相当于： @scope：作用域，包括singleton和prototype等 singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 @Configuration: 12//这个也会被Spring容器托管，注册到容器中，因为他本身就是一个@Component，// @Configuration代表这是一个配置类 ，就和我们之前看到的beans.xml @Import(KuangConfig2.class) 1导入别的配置文件（使用了注解@Configuration:） @ComponentScan(“com.kuang”) 12//扫描组件，相当于xml文件中的 &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt; @Bean: 123//注册一个Bean，就像但与我们之前写的一个bean标签//这个方法的名字，就相当于bean标签中的id属性//这个方法的返回值，就相当于bean标签中的class属性 springboot @ConfigurationProperties(prefix = &quot;person&quot;) 123456789 将配置文件中配置的每一个属性的值，映射到这个组件中； 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应- ```java @Validated //数据校验 @Email(message=&quot;邮箱格式错误&quot;) 1234567891011121314151617181920212223242526272829303132 配合@Validated使用，在字段上使用，要求其必须为邮件格式，否则报错（邮箱格式错误）- jsr303检验 ```java @NotNull(message=&quot;名字不能为空&quot;) private String userName;get @Max(value=120,message=&quot;年龄最大不能查过120&quot;) private int age; @Email(message=&quot;邮箱格式错误&quot;) private String email; 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern(value) 验证 String 对象是否符合正则表达式的规则 @Repository else 实现异步 @Async：在方法上加，告诉spring这是一个异步的方法 @EnableAsync：在SpringbootApplication上面加，开启异步注解功能 定时执行任务 @Scheduled（）：在方法上加，使用cron表达式 cron表达式： 秒 分 时 日 月 周几 @Scheduled(cron &#x3D; “0 * * * * 0-7”)：每天任何时候的第0秒 可在线生成 @EnableScheduling：在SpringbootApplication上面加，开启定时功能的注解","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-03T12:52:23.253Z","updated":"2022-03-03T12:52:23.253Z","comments":true,"path":"2022/03/03/hello-world/","link":"","permalink":"https://blog.jiascu.top/2022/03/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}